---
description: 
globs: 
alwaysApply: false
---
# Elo Browser ë³´ì•ˆ ë° ì„±ëŠ¥ ê·œì¹™

ì´ ê·œì¹™ì€ Elo Browserì˜ ë³´ì•ˆ ê°•í™”ì™€ ì„±ëŠ¥ ìµœì í™”ë¥¼ ìœ„í•œ êµ¬ì²´ì ì¸ ê°€ì´ë“œë¼ì¸ì„ ì œê³µí•©ë‹ˆë‹¤.

## ğŸ”’ ë³´ì•ˆ ê·œì¹™

### Electron ë³´ì•ˆ ì„¤ì •

#### âœ… ì˜¬ë°”ë¥¸ BrowserWindow ì„¤ì •
```typescript
// âœ… ë³´ì•ˆì´ ê°•í™”ëœ ì°½ ìƒì„±
const createSecureWindow = () => {
  return new BrowserWindow({
    webPreferences: {
      nodeIntegration: false,           // Node.js í†µí•© ë¹„í™œì„±í™”
      contextIsolation: true,           // ì»¨í…ìŠ¤íŠ¸ ê²©ë¦¬ í™œì„±í™”
      sandbox: true,                    // ìƒŒë“œë°•ìŠ¤ í™œì„±í™”
      webSecurity: true,                // ì›¹ ë³´ì•ˆ í™œì„±í™”
      allowRunningInsecureContent: false, // ë¹„ë³´ì•ˆ ì½˜í…ì¸  ì°¨ë‹¨
      experimentalFeatures: false,       // ì‹¤í—˜ì  ê¸°ëŠ¥ ë¹„í™œì„±í™”
      preload: path.join(__dirname, 'preload.js')
    }
  });
};
```

#### âŒ ê¸ˆì§€ëœ ì„¤ì •
```typescript
// âŒ ë³´ì•ˆ ìœ„í—˜ì´ ìˆëŠ” ì„¤ì •
const dangerousWindow = new BrowserWindow({
  webPreferences: {
    nodeIntegration: true,              // âŒ ë³´ì•ˆ ìœ„í—˜
    contextIsolation: false,            // âŒ ë³´ì•ˆ ìœ„í—˜
    webSecurity: false,                 // âŒ ë³´ì•ˆ ìœ„í—˜
    allowRunningInsecureContent: true   // âŒ ë³´ì•ˆ ìœ„í—˜
  }
});
```

### Content Security Policy (CSP)

#### âœ… ê°•í™”ëœ CSP ì„¤ì •
```typescript
// âœ… ì—„ê²©í•œ CSP ì •ì±…
const CSP_POLICY = {
  "default-src": ["'self'"],
  "script-src": ["'self'", "'wasm-unsafe-eval'"],
  "style-src": ["'self'", "'unsafe-inline'"],
  "img-src": ["'self'", "data:", "https:"],
  "font-src": ["'self'", "data:"],
  "connect-src": ["'self'", "https:"],
  "frame-src": ["'none'"],
  "object-src": ["'none'"],
  "base-uri": ["'self'"],
  "form-action": ["'self'"]
};
```

### IPC ë³´ì•ˆ

#### âœ… ì•ˆì „í•œ IPC í†µì‹ 
```typescript
// preload.js - âœ… ì•ˆì „í•œ API ë…¸ì¶œ
import { contextBridge, ipcRenderer } from 'electron';

contextBridge.exposeInMainWorld('elo', {
  // âœ… íƒ€ì… ì•ˆì „í•˜ê³  ê²€ì¦ëœ API
  browser: {
    createTab: (url: string) => {
      // URL ê²€ì¦
      if (!isValidUrl(url)) {
        throw new Error('Invalid URL');
      }
      return ipcRenderer.invoke('browser:create-tab', url);
    },
    
    closeTab: (tabId: number) => {
      // ID ê²€ì¦
      if (!Number.isInteger(tabId) || tabId < 0) {
        throw new Error('Invalid tab ID');
      }
      return ipcRenderer.invoke('browser:close-tab', tabId);
    }
  }
});

// âœ… URL ê²€ì¦ í•¨ìˆ˜
function isValidUrl(url: string): boolean {
  try {
    const parsed = new URL(url);
    return ['http:', 'https:', 'file:', 'flow:', 'flow-internal:'].includes(parsed.protocol);
  } catch {
    return false;
  }
}
```

#### âŒ ìœ„í—˜í•œ IPC íŒ¨í„´
```typescript
// âŒ ê²€ì¦ ì—†ëŠ” ì§ì ‘ ë…¸ì¶œ
contextBridge.exposeInMainWorld('dangerous', {
  executeCommand: (cmd: string) => ipcRenderer.invoke('exec', cmd), // âŒ ìœ„í—˜
  readFile: (path: string) => ipcRenderer.invoke('fs:read', path),  // âŒ ìœ„í—˜
  eval: (code: string) => ipcRenderer.invoke('eval', code)          // âŒ ë§¤ìš° ìœ„í—˜
});
```

### ë°ì´í„° ê²€ì¦ ë° ìƒˆë‹ˆíƒ€ì´ì œì´ì…˜

#### âœ… ì…ë ¥ ê²€ì¦
```typescript
// âœ… ì‚¬ìš©ì ì…ë ¥ ê²€ì¦
class InputValidator {
  static validateTabUrl(url: string): boolean {
    if (!url || typeof url !== 'string') return false;
    if (url.length > 2048) return false; // URL ê¸¸ì´ ì œí•œ
    
    try {
      const parsed = new URL(url);
      const allowedProtocols = ['http:', 'https:', 'file:', 'flow:', 'flow-internal:'];
      return allowedProtocols.includes(parsed.protocol);
    } catch {
      return false;
    }
  }

  static sanitizeSearchQuery(query: string): string {
    if (!query || typeof query !== 'string') return '';
    
    // HTML íƒœê·¸ ì œê±°
    const sanitized = query.replace(/<[^>]*>/g, '');
    
    // ê¸¸ì´ ì œí•œ
    return sanitized.slice(0, 500);
  }

  static validateExtensionId(id: string): boolean {
    // Chrome í™•ì¥ ID í˜•ì‹ ê²€ì¦ (32ì ì†Œë¬¸ì ì•ŒíŒŒë²³)
    return /^[a-z]{32}$/.test(id);
  }
}
```

## âš¡ ì„±ëŠ¥ ìµœì í™” ê·œì¹™

### ë©”ëª¨ë¦¬ ê´€ë¦¬

#### âœ… íš¨ìœ¨ì ì¸ íƒ­ ê´€ë¦¬
```typescript
// âœ… íƒ­ ì„œìŠ¤íœì…˜ ì‹œìŠ¤í…œ
class TabSuspensionManager {
  private suspendedTabs = new Map<number, TabState>();
  private readonly SUSPENSION_DELAY = 5 * 60 * 1000; // 5ë¶„

  async suspendInactiveTabs(): Promise<void> {
    const tabs = await this.getAllTabs();
    
    for (const tab of tabs) {
      if (this.shouldSuspend(tab)) {
        await this.suspendTab(tab.id);
      }
    }
  }

  private shouldSuspend(tab: Tab): boolean {
    return (
      !tab.isVisible &&
      !tab.isPlayingAudio &&
      !tab.isLoading &&
      Date.now() - tab.lastActiveTime > this.SUSPENSION_DELAY
    );
  }

  private async suspendTab(tabId: number): Promise<void> {
    const tab = await this.getTab(tabId);
    if (!tab) return;

    // íƒ­ ìƒíƒœ ì €ì¥
    this.suspendedTabs.set(tabId, {
      url: tab.url,
      title: tab.title,
      scrollPosition: await tab.getScrollPosition(),
      formData: await tab.getFormData()
    });

    // ë©”ëª¨ë¦¬ì—ì„œ í•´ì œ
    await tab.discard();
  }
}
```

#### âœ… ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€
```typescript
// âœ… ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì •ë¦¬
class ComponentWithCleanup extends React.Component {
  private eventListeners: Array<() => void> = [];

  componentDidMount() {
    const handleResize = () => this.handleResize();
    const handleScroll = () => this.handleScroll();

    window.addEventListener('resize', handleResize);
    window.addEventListener('scroll', handleScroll);

    // ì •ë¦¬ í•¨ìˆ˜ ì €ì¥
    this.eventListeners.push(
      () => window.removeEventListener('resize', handleResize),
      () => window.removeEventListener('scroll', handleScroll)
    );
  }

  componentWillUnmount() {
    // ëª¨ë“  ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì •ë¦¬
    this.eventListeners.forEach(cleanup => cleanup());
    this.eventListeners = [];
  }
}

// âœ… í›…ì—ì„œì˜ ì •ë¦¬
const useWindowSize = () => {
  const [size, setSize] = useState({ width: 0, height: 0 });

  useEffect(() => {
    const handleResize = () => {
      setSize({ width: window.innerWidth, height: window.innerHeight });
    };

    window.addEventListener('resize', handleResize);
    handleResize(); // ì´ˆê¸°ê°’ ì„¤ì •

    return () => window.removeEventListener('resize', handleResize);
  }, []);

  return size;
};
```

### ë Œë”ë§ ìµœì í™”

#### âœ… React ì„±ëŠ¥ ìµœì í™”
```typescript
// âœ… ë©”ëª¨ì´ì œì´ì…˜ í™œìš©
const TabList = React.memo(({ tabs, onTabSelect }: TabListProps) => {
  const memoizedTabs = useMemo(() => 
    tabs.map(tab => ({
      ...tab,
      favicon: tab.favicon || '/default-favicon.png'
    }))
  , [tabs]);

  const handleTabSelect = useCallback((tabId: number) => {
    onTabSelect(tabId);
  }, [onTabSelect]);

  return (
    <div className="tab-list">
      {memoizedTabs.map(tab => (
        <TabItem
          key={tab.id}
          tab={tab}
          onSelect={handleTabSelect}
        />
      ))}
    </div>
  );
});

// âœ… ê°€ìƒí™”ëœ ë¦¬ìŠ¤íŠ¸ (ë§ì€ í•­ëª© ì²˜ë¦¬ì‹œ)
const VirtualizedTabList = ({ tabs }: { tabs: Tab[] }) => {
  const [visibleRange, setVisibleRange] = useState({ start: 0, end: 20 });
  
  const visibleTabs = useMemo(() => 
    tabs.slice(visibleRange.start, visibleRange.end)
  , [tabs, visibleRange]);

  return (
    <VirtualList
      height={400}
      itemCount={tabs.length}
      itemSize={32}
      onRangeChange={setVisibleRange}
    >
      {visibleTabs.map(tab => (
        <TabItem key={tab.id} tab={tab} />
      ))}
    </VirtualList>
  );
};
```

#### âœ… ì§€ì—° ë¡œë”©
```typescript
// âœ… ì»´í¬ë„ŒíŠ¸ ì§€ì—° ë¡œë”©
const LazySettingsPanel = lazy(() => 
  import('./SettingsPanel').then(module => ({
    default: module.SettingsPanel
  }))
);

// âœ… ì´ë¯¸ì§€ ì§€ì—° ë¡œë”©
const LazyImage: React.FC<{ src: string; alt: string }> = ({ src, alt }) => {
  const [isLoaded, setIsLoaded] = useState(false);
  const [isInView, setIsInView] = useState(false);
  const imgRef = useRef<HTMLImageElement>(null);

  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setIsInView(true);
          observer.disconnect();
        }
      },
      { threshold: 0.1 }
    );

    if (imgRef.current) {
      observer.observe(imgRef.current);
    }

    return () => observer.disconnect();
  }, []);

  return (
    <img
      ref={imgRef}
      src={isInView ? src : ''}
      alt={alt}
      onLoad={() => setIsLoaded(true)}
      className={`transition-opacity ${isLoaded ? 'opacity-100' : 'opacity-0'}`}
      loading="lazy"
    />
  );
};
```

### ë„¤íŠ¸ì›Œí¬ ìµœì í™”

#### âœ… íš¨ìœ¨ì ì¸ ë°ì´í„° í˜ì¹­
```typescript
// âœ… ìš”ì²­ ì¤‘ë³µ ì œê±°
class RequestCache {
  private cache = new Map<string, Promise<any>>();
  private readonly TTL = 5 * 60 * 1000; // 5ë¶„

  async fetch<T>(url: string, options?: RequestInit): Promise<T> {
    const cacheKey = `${url}:${JSON.stringify(options)}`;
    
    // ìºì‹œëœ ìš”ì²­ì´ ìˆìœ¼ë©´ ì¬ì‚¬ìš©
    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey);
    }

    // ìƒˆ ìš”ì²­ ìƒì„±
    const request = fetch(url, options)
      .then(response => response.json())
      .catch(error => {
        this.cache.delete(cacheKey); // ì‹¤íŒ¨ì‹œ ìºì‹œì—ì„œ ì œê±°
        throw error;
      });

    this.cache.set(cacheKey, request);

    // TTL í›„ ìºì‹œì—ì„œ ì œê±°
    setTimeout(() => {
      this.cache.delete(cacheKey);
    }, this.TTL);

    return request;
  }
}

// âœ… ë°°ì¹˜ ìš”ì²­
class BatchRequestManager {
  private pendingRequests: Array<{
    id: string;
    resolve: (value: any) => void;
    reject: (error: any) => void;
  }> = [];
  
  private batchTimeout: NodeJS.Timeout | null = null;

  async request(id: string): Promise<any> {
    return new Promise((resolve, reject) => {
      this.pendingRequests.push({ id, resolve, reject });
      
      if (!this.batchTimeout) {
        this.batchTimeout = setTimeout(() => {
          this.processBatch();
        }, 50); // 50ms í›„ ë°°ì¹˜ ì²˜ë¦¬
      }
    });
  }

  private async processBatch(): Promise<void> {
    const requests = [...this.pendingRequests];
    this.pendingRequests = [];
    this.batchTimeout = null;

    try {
      const ids = requests.map(req => req.id);
      const results = await this.fetchBatch(ids);
      
      requests.forEach((req, index) => {
        req.resolve(results[index]);
      });
    } catch (error) {
      requests.forEach(req => req.reject(error));
    }
  }

  private async fetchBatch(ids: string[]): Promise<any[]> {
    const response = await fetch('/api/batch', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ ids })
    });
    return response.json();
  }
}
```

## ğŸ“Š ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§

### âœ… ì„±ëŠ¥ ë©”íŠ¸ë¦­ ìˆ˜ì§‘
```typescript
// âœ… ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ
class PerformanceMonitor {
  private metrics: PerformanceMetric[] = [];
  private observer: PerformanceObserver;

  constructor() {
    this.observer = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        this.recordMetric(entry);
      }
    });

    this.observer.observe({ entryTypes: ['measure', 'navigation', 'paint'] });
  }

  startMeasure(name: string): void {
    performance.mark(`${name}-start`);
  }

  endMeasure(name: string): void {
    performance.mark(`${name}-end`);
    performance.measure(name, `${name}-start`, `${name}-end`);
  }

  private recordMetric(entry: PerformanceEntry): void {
    this.metrics.push({
      name: entry.name,
      duration: entry.duration || 0,
      timestamp: Date.now()
    });

    // ë©”íŠ¸ë¦­ì´ ë„ˆë¬´ ë§ì´ ìŒ“ì´ë©´ ì •ë¦¬
    if (this.metrics.length > 1000) {
      this.metrics = this.metrics.slice(-500);
    }
  }

  getMetrics(): PerformanceMetric[] {
    return [...this.metrics];
  }

  // ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ëª¨ë‹ˆí„°ë§
  getMemoryUsage(): MemoryInfo | null {
    return (performance as any).memory || null;
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
const monitor = new PerformanceMonitor();

// íƒ­ ìƒì„± ì‹œê°„ ì¸¡ì •
monitor.startMeasure('tab-creation');
await createNewTab(url);
monitor.endMeasure('tab-creation');
```

## ğŸš¨ ë³´ì•ˆ ì²´í¬ë¦¬ìŠ¤íŠ¸

### ì½”ë“œ ë¦¬ë·°ì‹œ í™•ì¸ì‚¬í•­
- [ ] **Node.js í†µí•© ë¹„í™œì„±í™”**: `nodeIntegration: false`
- [ ] **ì»¨í…ìŠ¤íŠ¸ ê²©ë¦¬ í™œì„±í™”**: `contextIsolation: true`
- [ ] **ìƒŒë“œë°•ìŠ¤ í™œì„±í™”**: `sandbox: true`
- [ ] **ì…ë ¥ ê²€ì¦**: ëª¨ë“  ì‚¬ìš©ì ì…ë ¥ ê²€ì¦
- [ ] **ì¶œë ¥ ì¸ì½”ë”©**: XSS ë°©ì§€ë¥¼ ìœ„í•œ ì ì ˆí•œ ì¸ì½”ë”©
- [ ] **CSP ì ìš©**: ì—„ê²©í•œ Content Security Policy
- [ ] **HTTPS ê°•ì œ**: ëª¨ë“  ì™¸ë¶€ í†µì‹  HTTPS
- [ ] **ê¶Œí•œ ìµœì†Œí™”**: í•„ìš”í•œ ê¶Œí•œë§Œ ìš”ì²­

### ì„±ëŠ¥ ì²´í¬ë¦¬ìŠ¤íŠ¸
- [ ] **ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€**: ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì •ë¦¬
- [ ] **ì§€ì—° ë¡œë”©**: í•„ìš”í•œ ì‹œì ì—ë§Œ ë¡œë“œ
- [ ] **ë©”ëª¨ì´ì œì´ì…˜**: ë¶ˆí•„ìš”í•œ ì¬ê³„ì‚° ë°©ì§€
- [ ] **ê°€ìƒí™”**: ëŒ€ëŸ‰ ë°ì´í„° íš¨ìœ¨ì  ë Œë”ë§
- [ ] **ë°°ì¹˜ ì²˜ë¦¬**: ë„¤íŠ¸ì›Œí¬ ìš”ì²­ ìµœì í™”
- [ ] **ìºì‹±**: ì ì ˆí•œ ìºì‹± ì „ëµ
- [ ] **ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§**: ë©”íŠ¸ë¦­ ìˆ˜ì§‘ ë° ë¶„ì„

## ğŸ”§ ê°œë°œ ë„êµ¬ í™œìš©

### âœ… ë³´ì•ˆ í…ŒìŠ¤íŠ¸ ë„êµ¬
```bash
# npm auditìœ¼ë¡œ ì·¨ì•½ì  ê²€ì‚¬
bun audit

# ESLint ë³´ì•ˆ ê·œì¹™
npx eslint --ext .ts,.tsx src/ --config .eslintrc.security.js

# íƒ€ì… ì²´í¬
bun run typecheck
```

### âœ… ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ ë„êµ¬
```bash
# ë²ˆë“¤ í¬ê¸° ë¶„ì„
npx webpack-bundle-analyzer dist/

# ë©”ëª¨ë¦¬ í”„ë¡œíŒŒì¼ë§
node --inspect-brk=0.0.0.0:9229 dist/main.js

# ì„±ëŠ¥ ë²¤ì¹˜ë§ˆí¬
bun run benchmark
```

---

**ì´ ê·œì¹™ë“¤ì„ ì¤€ìˆ˜í•˜ì—¬ ì•ˆì „í•˜ê³  ê³ ì„±ëŠ¥ì˜ Elo Browserë¥¼ ê°œë°œí•˜ì„¸ìš”.**
